<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <meta name="description" content=""/>
    <link rel="stylesheet" href="index.css">
    <title>Title</title>
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
<div id="root"></div>
<script type="text/jsx">
    // Обнулить lots в текущем (глобальном state)
    let state = {
        time: new Date(),
        zone: 'PL',
        // 0. пока lots заполни моковыми данными.данными
        lots: null
    };

    const mockDataLots = [
        {
            id: 1,
            price: 16000,
            type: 'Web developers',
            description: 'Developers description',
            count: '16',
        }, {
            id: 2,
            price: 10000,
            type: 'Java',
            description: 'Developers description',
            count: '10',
        }, {
            id: 3,
            price: 3000,
            type: 'Python',
            description: 'Developers description',
            count: '3',
        },
    ];
    // Обьект api с методом get. В нем switch по "/lots", который возвращает Promise (Внутри Promise setTimeout, который возвращает массив лотов)
    const api = {
        get: (url) => {
            let promise;
            switch (url) {
                case '/lots':
                    promise = new Promise((resolve, reject) => {
                        setTimeout(() => {
                            resolve(mockDataLots);
                        }, 1000);
                    });
                    break;
                default:
                    console.log('Такого URL к сожалению не найдено :(');
            }

            return promise;
        },
    }
    // реализовать обьект stream с методом subscribe (он принимает channel ("price-id"), listener). В самом subscribe
    const stream = {
        subscribe: (countId = '', listener) => {
            // регекспом проверяешь на совпадение формата "price-id".
            // Если формат совпал, то вызываешь setInterval,
            // в котором вызываешь listener - передаешь туда новый обьект с принятым {id, count: random от 0 до 100}
            const regex = /^count-[0-9a-zA-Z]*$/;
            const isFormat = regex.test(countId)
            if (isFormat) {
                setInterval(() => {
                    const id = Number(countId.split('-')[1]);
                    const count = Math.floor(Math.random() * 101);
                    const updateLotObj = {
                        id,
                        count
                    }
                    listener(updateLotObj);
                }, 1000)
            }
        }
    }

    function listener(updateLotObj) {
        state.lots.forEach(lot => {
            if (lot.id === updateLotObj.id) {
                lot.count = updateLotObj.count;
            }
        })
        renderView(state);
    }

    // 3. Создать функцию renderView,
    function renderView(state) {
        ReactDOM.render(React.createElement(App, state), document.getElementById('root'));
    }

    function Header() {
        return <div className='header'>
            <Logo/>
        </div>
    }

    function Logo() {
        return <img src='./icons/senla.svg'/>
    }

    function Preloader() {
        return <img className='preloader'/>
    }

    function Clock({time}) {
        const isFormatTime = time.getHours() >= 12 && time.getHours() !== 0;
        const currentFormat = <span>
            {`${time.toLocaleTimeString()} ${(isFormatTime ? 'PM' : 'AM')}`}
        </span>

        return <div className='clock'>
            {currentFormat}
        </div>
    }

    function Lot({lot}) {
        return <article className='lot'>
            <div>
                <div className='type'>
                    {lot.type}
                </div>
                <div>
                    {lot.count}
                </div>
            </div>
            <div>{lot.description}</div>
        </article>
    }

    function Lots({lots}) {
        if (lots === null) {
            return <Preloader/>
        }

        const children = lots.map(lot => {
                return <Lot key={lot.id} lot={lot}/>
            }
        );

        return <div>
            {children}
        </div>
    }

    function App({time, lots}) {
        return <div className='app'>
            <Header/>
            <Clock time={time}/>
            <Lots lots={lots}/>
        </div>
    }

    //api получает lots (в then), обновляет state и вызывает renderView, ps/ не забывай про catch у промиса.
    api.get('/lots')
        .then(result => {
            // 3. В этом же then описываешь  callback (listener).
            // Он принимает обьект  - меняешь count в state на тот,
            // который принял и вызываешь renderView
            result.forEach(lot => {
                stream.subscribe(`count-${lot.id}`, listener)
            });
            state.lots = result;
            renderView(state);
        })
        .catch(error => {
            console.log('Что-то пошло не так');
        });
    // Реализовать setInterval. Он каждую секунду меняет time у state и пердает весь state в renderView
    setInterval(function () {
        state.time = new Date();
        renderView(state);
    }, 1000);
    renderView(state);
</script>
</body>
</html>